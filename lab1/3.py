from numpy import arange

e = 3e-8

s1_answers = [4.80121822020343502882877982027,3.87184754795850909606465941888,3.45841679554902525801640730678,3.21076364104978708986392385719,3.04084099071321932963566321236,2.91467555541694883385640257382,2.81601284873604111757116588985,2.73596928032731211879912686626,2.66922534925184228994023164253,2.61237534868548834334789184423,2.56312419595199962154757049145,2.51986121268479777170728081955,2.48141816582448745015139467193,2.44692426883567136695729417848,2.41571533384062881387063184352,2.38727469034431658451787722042,2.36119352585897436110191825753,2.33714352743022479952050185828,2.31485755513128250196042010057]
s2_answers = s1_answers[::-1]
s_answers = [i-j for i,j in zip(s1_answers,s2_answers)]

# a) по интегральному признаку ряды сходятся

# б) экспериментальным путем было выявлено, что для ошибки меньше e понадобится около 1e+17 элементов ряда.

# в) соответственно 500*2*1e+17 = 1e+20

# s1 = lambda k,x : 1/(k**3 + x)**(0.5)
# s2 = lambda k,x : 1/(k**3 - x)**(0.5)

# for x in zip(arange(-0.9,1.0,0.1),s1_answers): # вот здесь менять s1|s2
#     k = 1
#     tek = s1(k,x[0]) # вот здесь менять s1|s2
#     res = tek
#     while abs(res-x[1]) > e:
#         if k%1000000 == 0:
#             print(res, abs(res-x[1]) - e)
#         k+=1
#         tek = s1(k,x[0]) # вот здесь менять s1|s2
#         res += tek
#     print(f'x = {x[0]:.1f}; k = {k}; s1 = {res}') # вот здесь менять s1|s2

# г) вычисление рядов можно объединить в один:

s = lambda k,x : 1/(k**3 + x)**(0.5) - 1/(k**3 - x)**(0.5)

for x in zip([0.5, 0.999999999],[-0.625125656872590515765031368831,-31622.1250930051870773156939554]):
    k = 1
    tek = s(k,x[0])
    res = tek
    while abs(res-x[1]) > e:
        k+=1
        tek = s(k,x[0])
        res += tek
    print(f'x = {x[0]}; k = {k}; s = {res}; ')


# д)

# x = 0.5; k = 81; s = -0.6251256276440297; 
# x = 0.999999999; k = 99; s = -31622.125092976094; 